<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¥åº·æ ¡åœ’è¿·å®®å°‹å¯¶</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Microsoft JhengHei', sans-serif; background-color: #87CEEB; }
        #game-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* Top HUD */
        #hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
            color: white;
        }

        #stats {
            font-size: 1.2rem;
            text-shadow: 2px 2px 2px #000;
        }

        #mini-map-container {
            width: 150px;
            height: 150px;
            border: 4px solid #fff;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        #mini-map {
            width: 100%;
            height: 100%;
        }

        /* Instructions */
        #instructions {
            position: absolute;
            bottom: 150px; /* ç§»é«˜ä¸€é»ï¼Œé¿é–‹è§¸æ§æŒ‰éˆ• */
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            text-shadow: 2px 2px 4px #000;
            font-size: 1.2rem;
            background-color: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 20px;
        }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 180px;
            pointer-events: none; /* è®“é»æ“Šç©¿é€ç©ºç™½è™• */
            display: flex;
            justify-content: space-between;
            padding: 0 40px;
            box-sizing: border-box;
            z-index: 10;
        }

        .control-group {
            pointer-events: auto; /* æŒ‰éˆ•å€åŸŸæ¢å¾©é»æ“Š */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #d-pad {
            position: relative;
            width: 180px;
            height: 180px;
        }

        .ctrl-btn {
            background-color: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 15px;
            color: white;
            font-size: 24px;
            position: absolute;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            -webkit-user-select: none; /* Safari */
            touch-action: manipulation;
            backdrop-filter: blur(4px);
            transition: background 0.1s;
        }

        .ctrl-btn:active, .ctrl-btn.active {
            background-color: rgba(76, 175, 80, 0.8);
            transform: scale(0.95);
        }

        #btn-up { top: 0; left: 60px; }
        #btn-down { bottom: 0; left: 60px; }
        #btn-left { top: 60px; left: 0; }
        #btn-right { top: 60px; right: 0; }

        #action-btn {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background-color: rgba(255, 215, 0, 0.4);
            border: 4px solid rgba(255, 215, 0, 0.8);
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            margin-bottom: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        #action-btn:active {
            background-color: rgba(255, 215, 0, 0.8);
            transform: scale(0.95);
        }

        /* Interaction Message */
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px 40px;
            border-radius: 15px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            color: #333;
            border: 4px solid #4CAF50;
            display: none;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            pointer-events: auto;
        }

        .item-icon { margin-right: 5px; }
        .collected { color: #4CAF50; font-weight: bold; }
        .key-text { color: #FFD700; font-weight: bold; }

        /* Start Screen */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 100;
            pointer-events: auto;
        }
        
        button {
            padding: 15px 30px;
            font-size: 1.5rem;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.2s;
        }
        button:hover { transform: scale(1.05); background-color: #45a049; }

        /* å¹³æ¿æ©«å‘å„ªåŒ– */
        @media (max-width: 800px) {
            #mobile-controls {
                padding: 0 20px;
            }
        }
    </style>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div id="hud-top">
            <div id="stats">
                <div>ç›®æ¨™ï¼šè’é›† 3 å€‹é‹å‹•å™¨æèˆ‡ 1 æŠŠé‘°åŒ™</div>
                <div id="inventory-list">
                    å™¨æï¼š<span id="score">0</span> / 3<br>
                    é‘°åŒ™ï¼š<span id="has-key" style="color:red">æœªå–å¾—</span>
                </div>
            </div>
            <div id="mini-map-container">
                <canvas id="mini-map" width="150" height="150"></canvas>
            </div>
        </div>
        
        <div id="instructions">
            ä½¿ç”¨ â¬†ï¸â¬‡ï¸â¬…ï¸â¡ï¸ æˆ– WASD ç§»å‹•<br>é è¿‘å¯¶ç®±æŒ‰ç©ºç™½éµ [SPACE] æˆ–é»æ“Šå³ä¸‹è§’æŒ‰éˆ•
        </div>

        <!-- è§¸æ§æŒ‰éˆ•å€ -->
        <div id="mobile-controls">
            <div class="control-group" id="d-pad">
                <div class="ctrl-btn" id="btn-up">â–²</div>
                <div class="ctrl-btn" id="btn-left">â—€</div>
                <div class="ctrl-btn" id="btn-right">â–¶</div>
                <div class="ctrl-btn" id="btn-down">â–¼</div>
            </div>
            <div class="control-group">
                <div id="action-btn">ğŸ–ï¸ é–‹å•Ÿ</div>
            </div>
        </div>
    </div>

    <div id="message-box">
        <div id="msg-content">ç²å¾—ç‰©å“ï¼</div>
        <button onclick="closeMessage()">ç¹¼çºŒæ¢ç´¢</button>
    </div>

    <div id="start-screen">
        <h1>ğŸƒ å¥åº·æ ¡åœ’è¿·å®®å°‹å¯¶ ğŸƒ</h1>
        <p style="font-size: 1.2rem; max-width: 600px; text-align: center; line-height: 1.6;">
            æ­¡è¿ä¾†åˆ°å¥åº·è¿·å®®ï¼ä½ éœ€è¦æ‰¾åˆ°æ•£è½åœ¨è¿·å®®ä¸­çš„<b>é‹å‹•å™¨æ</b>ï¼ˆç±ƒçƒã€æ°´å£ºã€å•éˆ´ï¼‰ä¾†å¢å¼·é«”åŠ›ï¼Œä¸¦æ‰¾åˆ°<b>é»ƒé‡‘é‘°åŒ™</b>æ‰èƒ½æ‰“é–‹æ ¡åœ’å¤§é–€é›¢é–‹ã€‚<br><br>
            è§€å¯Ÿå³ä¸Šè§’çš„å°åœ°åœ–ï¼Œä¸è¦è¿·è·¯å›‰ï¼
        </p>
        <button id="start-btn">é–‹å§‹å†’éšª</button>
    </div>

    <script>
        // --- éŠæˆ²è¨­å®š ---
        const MAZE_SIZE = 15; // è¿·å®®å¤§å° (å¥‡æ•¸)
        const CELL_SIZE = 40; // æ¯å€‹æ ¼å­çš„ 3D å°ºå¯¸
        const WALL_HEIGHT = 40;
        const PLAYER_SPEED = 2.0;
        const ROTATION_SPEED = 0.04;
        const INTERACTION_DIST = 30; // ç¨å¾®å¢åŠ äº’å‹•è·é›¢

        // --- å…¨åŸŸè®Šæ•¸ ---
        let scene, camera, renderer;
        let maze = [];
        let walls = []; // å„²å­˜ç‰†å£ Mesh ç”¨æ–¼ç¢°æ’
        let player = { x: 0, z: 0, rotation: 0, dirX: 0, dirZ: 1 };
        let objects = []; // å¯¶ç®±èˆ‡çµ‚é»
        let itemsCollected = 0;
        let hasKey = false;
        let isGameActive = false;
        
        // é‹å‹•å™¨ææ¸…å–®
        const ITEMS = [
            { name: "ç±ƒçƒ", color: 0xff6600, type: 'sphere' },
            { name: "é‹å‹•æ°´å£º", color: 0x0000ff, type: 'cylinder' },
            { name: "å•éˆ´", color: 0x555555, type: 'dumbbell' }
        ];
        
        // --- åˆå§‹åŒ– Three.js ---
        function init() {
            const container = document.getElementById('game-container');
            
            // å ´æ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // å¤©ç©ºè—
            scene.fog = new THREE.Fog(0x87CEEB, 20, 300);

            // æ”å½±æ©Ÿ (ç¬¬ä¸€äººç¨±)
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // ç‡ˆå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(100, 200, 100);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // ç©å®¶æ‰‹é›»ç­’ (è®“è¿·å®®ä¸è¦å¤ªæš—)
            const pointLight = new THREE.PointLight(0xffaa00, 0.5, 100);
            camera.add(pointLight);
            scene.add(camera);

            // åœ°æ¿
            createFloor();

            // ç”Ÿæˆè¿·å®®èˆ‡ç‰†å£
            generateMaze(MAZE_SIZE, MAZE_SIZE);
            buildMaze3D();

            // æ”¾ç½®ç‰©ä»¶
            placeObjects();

            // äº‹ä»¶ç›£è½
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.getElementById('start-btn').addEventListener('click', startGame);

            // è§¸æ§æŒ‰éˆ•ç›£è½
            setupTouchControls();

            // éŠæˆ²è¿´åœˆ
            animate();
        }

        // --- è§¸æ§æ§åˆ¶è¨­å®š ---
        function setupTouchControls() {
            const bindTouch = (id, key) => {
                const btn = document.getElementById(id);
                // ä½¿ç”¨ touchstart/touchend æ”¯æ´å¤šé»è§¸æ§
                btn.addEventListener('touchstart', (e) => { 
                    e.preventDefault(); 
                    keys[key] = true; 
                    btn.classList.add('active');
                }, {passive: false});
                
                btn.addEventListener('touchend', (e) => { 
                    e.preventDefault(); 
                    keys[key] = false; 
                    btn.classList.remove('active');
                }, {passive: false});

                // æ»‘é¼ æ”¯æ´ (æ–¹ä¾¿é›»è…¦æ¸¬è©¦)
                btn.addEventListener('mousedown', () => { keys[key] = true; btn.classList.add('active'); });
                btn.addEventListener('mouseup', () => { keys[key] = false; btn.classList.remove('active'); });
                btn.addEventListener('mouseleave', () => { keys[key] = false; btn.classList.remove('active'); });
            };

            bindTouch('btn-up', 'w');
            bindTouch('btn-down', 's');
            bindTouch('btn-left', 'a');
            bindTouch('btn-right', 'd');

            const actionBtn = document.getElementById('action-btn');
            actionBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                handleInteraction();
                actionBtn.style.transform = "scale(0.9)";
                setTimeout(() => actionBtn.style.transform = "scale(1)", 100);
            }, {passive: false});
            
            actionBtn.addEventListener('click', () => handleInteraction()); // é›»è…¦é»æ“Š
        }

        // --- è¿·å®®æ¼”ç®—æ³• (éæ­¸å›æº¯ Recursive Backtracker) ---
        function generateMaze(width, height) {
            // åˆå§‹åŒ–å…¨ç‚ºç‰† (1)
            maze = Array(height).fill().map(() => Array(width).fill(1));
            
            // å…¶å¯¦é» (1,1)
            const startX = 1;
            const startY = 1;
            maze[startY][startX] = 0;
            
            const stack = [{x: startX, y: startY}];
            const directions = [[0, -2], [0, 2], [-2, 0], [2, 0]]; // ä¸Šä¸‹å·¦å³è·³å…©æ ¼

            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = [];

                for (let dir of directions) {
                    const nx = current.x + dir[0];
                    const ny = current.y + dir[1];
                    
                    if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1 && maze[ny][nx] === 1) {
                        neighbors.push({x: nx, y: ny, dx: dir[0] / 2, dy: dir[1] / 2});
                    }
                }

                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    maze[next.y][next.x] = 0; // æ‰“é€šç›®æ¨™é»
                    maze[current.y + next.dy][current.x + next.dx] = 0; // æ‰“é€šä¸­é–“ç‰†
                    stack.push({x: next.x, y: next.y});
                } else {
                    stack.pop();
                }
            }

            // ç¢ºä¿èµ·é»å’Œéš¨æ©Ÿä½ç½®æ˜¯ç©ºçš„ï¼Œä¾¿æ–¼æ”¾ç½®ç©å®¶
            // ä¿®æ­£ï¼šåŠ ä¸Š CELL_SIZE / 2 ä½¿ç©å®¶ä½æ–¼æ ¼å­æ­£ä¸­å¿ƒ
            player.x = 1 * CELL_SIZE + CELL_SIZE / 2;
            player.z = 1 * CELL_SIZE + CELL_SIZE / 2;
        }

        // --- ç´‹ç†ç”Ÿæˆå™¨ (ç„¡éœ€å¤–éƒ¨åœ–ç‰‡) ---
        function createBrickTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#d2691e'; // ç£šå¡Šåº•è‰²
            ctx.fillRect(0, 0, 64, 64);
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 3;
            // ç•«ç£šç¸«
            ctx.beginPath();
            ctx.moveTo(0, 32); ctx.lineTo(64, 32);
            ctx.moveTo(32, 0); ctx.lineTo(32, 32);
            ctx.moveTo(0, 0); ctx.lineTo(64, 0); ctx.lineTo(64, 64); ctx.lineTo(0, 64); ctx.lineTo(0,0);
            ctx.stroke();
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            return tex;
        }

        function createFloor() {
            const geometry = new THREE.PlaneGeometry(MAZE_SIZE * CELL_SIZE * 2, MAZE_SIZE * CELL_SIZE * 2);
            
            // è‰åœ°ç´‹ç†
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(0,0,64,64);
            ctx.fillStyle = '#388E3C'; // é›œè‰é»ç¶´
            for(let i=0; i<20; i++) ctx.fillRect(Math.random()*64, Math.random()*64, 4, 4);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(50, 50);

            const material = new THREE.MeshLambertMaterial({ map: texture });
            const floor = new THREE.Mesh(geometry, material);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);
        }

        // --- å»ºç«‹ 3D è¿·å®® ---
        function buildMaze3D() {
            const brickTexture = createBrickTexture();
            const wallGeo = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
            const wallMat = new THREE.MeshLambertMaterial({ map: brickTexture });

            for (let z = 0; z < MAZE_SIZE; z++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    if (maze[z][x] === 1) {
                        const wall = new THREE.Mesh(wallGeo, wallMat);
                        // ä¿®æ­£ï¼šåº§æ¨™åŠ ä¸Š CELL_SIZE / 2
                        wall.position.set(x * CELL_SIZE + CELL_SIZE / 2, WALL_HEIGHT / 2, z * CELL_SIZE + CELL_SIZE / 2);
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        scene.add(wall);
                        walls.push(wall);
                    }
                }
            }
            
            // å»ºç«‹é‚Šç•Œåœç‰†
            // (ç°¡å–®èµ·è¦‹ï¼Œè¿·å®®ç”Ÿæˆé‚è¼¯å·²åŒ…å«é‚Šç•Œï¼Œè‹¥ç„¡å‰‡éœ€é¡å¤–æ·»åŠ )
        }

        // --- æ”¾ç½®ç‰©ä»¶ ---
        function placeObjects() {
            // æ‰¾å‡ºæ‰€æœ‰ç©ºåœ°
            let emptySpots = [];
            for(let z=1; z<MAZE_SIZE-1; z++){
                for(let x=1; x<MAZE_SIZE-1; x++){
                    if(maze[z][x] === 0 && !(x===1 && z===1)) { // æ’é™¤èµ·é»
                        emptySpots.push({x: x, z: z});
                    }
                }
            }

            // æ´—ç‰Œ
            emptySpots.sort(() => Math.random() - 0.5);

            // 1. æ”¾ç½®çµ‚é»å¤§é–€ (æœ€å¾Œä¸€å€‹ä½ç½®)
            const exitSpot = emptySpots.pop();
            createExit(exitSpot.x, exitSpot.z);

            // 2. æ”¾ç½®é‘°åŒ™ (å€’æ•¸ç¬¬äºŒå€‹ä½ç½®)
            const keySpot = emptySpots.pop();
            createChest(keySpot.x, keySpot.z, 'key');

            // 3. æ”¾ç½®é‹å‹•å™¨æ (å–å‰3å€‹)
            for (let i = 0; i < 3; i++) {
                if(emptySpots.length > 0) {
                    const spot = emptySpots.pop();
                    createChest(spot.x, spot.z, 'item', ITEMS[i]);
                }
            }
        }

        function createChest(x, z, type, itemData) {
            // å¯¶ç®±ä¸»é«”
            const geometry = new THREE.BoxGeometry(15, 15, 15);
            const material = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // æ£•è‰²
            const chest = new THREE.Mesh(geometry, material);
            
            // é‡‘è‰²è“‹å­
            const lidGeo = new THREE.BoxGeometry(16, 5, 16);
            const lidMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            const lid = new THREE.Mesh(lidGeo, lidMat);
            lid.position.y = 8;
            chest.add(lid);

            // ä¿®æ­£ï¼šåº§æ¨™åŠ ä¸Š CELL_SIZE / 2
            chest.position.set(x * CELL_SIZE + CELL_SIZE / 2, 7.5, z * CELL_SIZE + CELL_SIZE / 2);
            scene.add(chest);

            objects.push({
                mesh: chest,
                type: type, // 'key' or 'item'
                data: itemData,
                collected: false,
                gridX: x,
                gridZ: z
            });
        }

        function createExit(x, z) {
            // å¤§é–€æ‹±é–€
            const group = new THREE.Group();
            
            const pillarGeo = new THREE.CylinderGeometry(2, 2, 60);
            const pillarMat = new THREE.MeshLambertMaterial({color: 0x888888});
            
            const p1 = new THREE.Mesh(pillarGeo, pillarMat);
            p1.position.set(-10, 30, 0);
            const p2 = new THREE.Mesh(pillarGeo, pillarMat);
            p2.position.set(10, 30, 0);
            
            const topGeo = new THREE.BoxGeometry(30, 5, 5);
            const top = new THREE.Mesh(topGeo, pillarMat);
            top.position.set(0, 60, 0);

            // å…‰é–€ (åŠé€æ˜)
            const doorGeo = new THREE.PlaneGeometry(20, 60);
            const doorMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
            const door = new THREE.Mesh(doorGeo, doorMat);
            door.position.set(0, 30, 0);

            group.add(p1, p2, top, door);
            // ä¿®æ­£ï¼šåº§æ¨™åŠ ä¸Š CELL_SIZE / 2
            group.position.set(x * CELL_SIZE + CELL_SIZE / 2, 0, z * CELL_SIZE + CELL_SIZE / 2);
            scene.add(group);

            objects.push({
                mesh: group,
                type: 'exit',
                gridX: x,
                gridZ: z
            });
        }

        // --- æ§åˆ¶èˆ‡ç§»å‹• ---
        const keys = { w: false, a: false, s: false, d: false, space: false };

        function onKeyDown(event) {
            const key = event.key.toLowerCase();
            if (key === 'w' || key === 'arrowup') keys.w = true;
            if (key === 's' || key === 'arrowdown') keys.s = true;
            if (key === 'a' || key === 'arrowleft') keys.a = true;
            if (key === 'd' || key === 'arrowright') keys.d = true;
            if (key === ' ') handleInteraction();
        }

        function onKeyUp(event) {
            const key = event.key.toLowerCase();
            if (key === 'w' || key === 'arrowup') keys.w = false;
            if (key === 's' || key === 'arrowdown') keys.s = false;
            if (key === 'a' || key === 'arrowleft') keys.a = false;
            if (key === 'd' || key === 'arrowright') keys.d = false;
        }

        function updatePlayer() {
            if (!isGameActive) return;

            // æ—‹è½‰
            if (keys.a) player.rotation += ROTATION_SPEED;
            if (keys.d) player.rotation -= ROTATION_SPEED;

            // è¨ˆç®—ç§»å‹•å‘é‡
            const dx = Math.sin(player.rotation) * PLAYER_SPEED;
            const dz = Math.cos(player.rotation) * PLAYER_SPEED;
            
            // é æ¸¬æ–°ä½ç½®
            let nextX = player.x;
            let nextZ = player.z;

            if (keys.w) {
                nextX -= dx;
                nextZ -= dz;
            }
            if (keys.s) {
                nextX += dx;
                nextZ += dz;
            }

            // ç°¡å–®ç¢°æ’æª¢æ¸¬ (å°‡ä½ç½®æ˜ å°„å›ç¶²æ ¼)
            // çµ¦äºˆä¸€é»ç·©è¡ç©ºé–“ (åŠå¾‘)
            const padding = 10;
            const checkCollision = (x, z) => {
                // å› ç‚ºæˆ‘å€‘åšäº†åç§»ï¼Œè¨ˆç®—ç¶²æ ¼æ™‚è¦å°å¿ƒ
                // ç¶²æ ¼ 0 çš„ç¯„åœæ˜¯ 0-40, ç¶²æ ¼ 1 æ˜¯ 40-80
                // æ‰€ä»¥ floor(x/CELL_SIZE) å°±æ˜¯æ­£ç¢ºçš„ç¶²æ ¼ç´¢å¼•
                const gridX = Math.floor((x + padding) / CELL_SIZE);
                const gridX2 = Math.floor((x - padding) / CELL_SIZE);
                const gridZ = Math.floor((z + padding) / CELL_SIZE);
                const gridZ2 = Math.floor((z - padding) / CELL_SIZE);

                // é‚Šç•Œæª¢æŸ¥
                if (gridX < 0 || gridX >= MAZE_SIZE || gridZ < 0 || gridZ >= MAZE_SIZE) return true;

                // æª¢æŸ¥å››å€‹è§’æ˜¯å¦ç¢°åˆ°ç‰†
                if (maze[gridZ][gridX] === 1 || maze[gridZ2][gridX2] === 1 || 
                    maze[gridZ][gridX2] === 1 || maze[gridZ2][gridX] === 1) {
                    return true;
                }
                return false;
            };

            // åˆ†è»¸æª¢æ¸¬ï¼Œå…è¨±æ²¿ç‰†æ»‘å‹•
            if (!checkCollision(nextX, player.z)) player.x = nextX;
            if (!checkCollision(player.x, nextZ)) player.z = nextZ;

            // æ›´æ–°ç›¸æ©Ÿä½ç½®
            camera.position.x = player.x;
            camera.position.z = player.z;
            camera.position.y = 15; // è¦–ç·šé«˜åº¦
            camera.rotation.y = player.rotation; // è¦–è§’æ—‹è½‰
        }

        function handleInteraction() {
            if (!isGameActive) return;

            // å°‹æ‰¾æœ€è¿‘çš„ç‰©ä»¶
            let nearObj = null;
            let minDist = INTERACTION_DIST;

            objects.forEach(obj => {
                if (obj.collected) return;
                const dist = Math.sqrt((player.x - obj.mesh.position.x)**2 + (player.z - obj.mesh.position.z)**2);
                if (dist < minDist) {
                    nearObj = obj;
                }
            });

            if (nearObj) {
                if (nearObj.type === 'item') {
                    collectItem(nearObj);
                } else if (nearObj.type === 'key') {
                    collectKey(nearObj);
                } else if (nearObj.type === 'exit') {
                    checkExit();
                }
            }
        }

        function collectItem(obj) {
            obj.collected = true;
            obj.mesh.visible = false;
            itemsCollected++;
            document.getElementById('score').innerText = itemsCollected;
            showMessage(`ç²å¾—ï¼š${obj.data.name}ï¼<br>é«”åŠ›å……æ²›ï¼`);
        }

        function collectKey(obj) {
            obj.collected = true;
            obj.mesh.visible = false;
            hasKey = true;
            const keyEl = document.getElementById('has-key');
            keyEl.innerText = "å·²å–å¾— (ğŸ”‘)";
            keyEl.style.color = "#4CAF50";
            showMessage(`ç²å¾—ï¼šé»ƒé‡‘é‘°åŒ™ï¼<br>å¿«å»æ‰¾å‡ºå£å¤§é–€ï¼`);
        }

        function checkExit() {
            if (hasKey && itemsCollected >= 3) {
                isGameActive = false;
                showMessage(`ğŸ‰ æ­å–œé€šé—œï¼ ğŸ‰<br>ä½ æˆåŠŸæ‰¾åˆ°äº†æ‰€æœ‰å™¨æä¸¦é›¢é–‹äº†è¿·å®®ï¼`, true);
            } else {
                let msg = "é–€é–è‘—ï¼<br>";
                if (itemsCollected < 3) msg += `é‚„ç¼º ${3 - itemsCollected} å€‹å™¨æã€‚<br>`;
                if (!hasKey) msg += "é‚„æ²’æœ‰é‘°åŒ™ã€‚";
                showMessage(msg);
            }
        }

        // --- UI èˆ‡ å°åœ°åœ– ---
        function showMessage(text, isWin = false) {
            const box = document.getElementById('message-box');
            const content = document.getElementById('msg-content');
            content.innerHTML = text;
            box.style.display = 'block';
            
            // æš«åœç§»å‹•æ§åˆ¶
            const oldState = isGameActive;
            isGameActive = false;
            
            // ä¿®æ”¹æŒ‰éˆ•è¡Œç‚º
            const btn = box.querySelector('button');
            if (isWin) {
                btn.innerText = "é‡æ–°é–‹å§‹";
                btn.onclick = () => location.reload();
            } else {
                btn.innerText = "ç¹¼çºŒ";
                btn.onclick = () => {
                    box.style.display = 'none';
                    isGameActive = true;
                };
            }
        }

        function closeMessage() {
            document.getElementById('message-box').style.display = 'none';
            isGameActive = true;
        }

        function drawMiniMap() {
            const canvas = document.getElementById('mini-map');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            // æ¸…é™¤
            ctx.fillStyle = '#222';
            ctx.fillRect(0, 0, w, h);

            const mapScale = w / (MAZE_SIZE * CELL_SIZE); // ç¸®æ”¾æ¯”ä¾‹

            // 1. ç¹ªè£½è¿·å®®ç‰†å£
            ctx.fillStyle = '#666';
            for (let z = 0; z < MAZE_SIZE; z++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    if (maze[z][x] === 1) {
                        ctx.fillRect(x * CELL_SIZE * mapScale, z * CELL_SIZE * mapScale, CELL_SIZE * mapScale, CELL_SIZE * mapScale);
                    }
                }
            }

            // 2. ç¹ªè£½æœªæ”¶é›†çš„å¯¶ç‰© (é»ƒé»)
            objects.forEach(obj => {
                if (!obj.collected && obj.type !== 'exit') {
                    ctx.fillStyle = obj.type === 'key' ? '#FFD700' : '#00FF00';
                    const ox = obj.mesh.position.x * mapScale;
                    const oz = obj.mesh.position.z * mapScale;
                    ctx.beginPath();
                    ctx.arc(ox, oz, 4, 0, Math.PI*2); // ç¨å¾®åŠ å¤§é»
                    ctx.fill();
                } else if (obj.type === 'exit') {
                    ctx.fillStyle = '#00FFFF'; // å‡ºå£è—è‰²
                    const ox = obj.mesh.position.x * mapScale;
                    const oz = obj.mesh.position.z * mapScale;
                    ctx.fillRect(ox - 4, oz - 4, 8, 8);
                }
            });

            // 3. ç¹ªè£½ç©å®¶ (ç´…è‰²ç®­é ­)
            const px = player.x * mapScale;
            const pz = player.z * mapScale;

            ctx.translate(px, pz);
            
            // ä¿®æ­£ï¼šæ—‹è½‰è¨ˆç®—ã€‚
            // éŠæˆ²ä¸­ Rot=0 æ˜¯æœå‘ -Z (åœ°åœ–ä¸Šæ–¹)ã€‚
            // Canvas ä¸­ -PI/2 æ˜¯æœå‘ ä¸Šæ–¹ã€‚
            // éŠæˆ²ä¸­ 'A' éµå¢åŠ  Rotation (å‘å·¦è½‰)ã€‚
            // Canvas ä¸­é€†æ™‚é‡æ—‹è½‰æ˜¯è² è§’åº¦ (æˆ–æ­£è§’åº¦å–æ±ºæ–¼åæ¨™ç³»ï¼Œé€šå¸¸ rotate() æ˜¯é †æ™‚é‡)ã€‚
            // é€™è£¡ä½¿ç”¨ -player.rotation - Math.PI / 2 ä¾†å°é½Š
            ctx.rotate(-player.rotation - Math.PI / 2); 
            
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.moveTo(0, -8); // ç®­é ­å°–ç«¯ (æ›´é•·ä¸€é»)
            ctx.lineTo(5, 5);
            ctx.lineTo(0, 2);
            ctx.lineTo(-5, 5);
            ctx.fill();

            // é‡ç½®çŸ©é™£
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        // --- ç³»çµ±åŠŸèƒ½ ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            isGameActive = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePlayer();
            drawMiniMap();
            
            // è®“å¯¶ç®±æµ®å‹•æˆ–æ—‹è½‰å¢åŠ è¦–è¦ºæ•ˆæœ
            objects.forEach(obj => {
                if (!obj.collected && obj.mesh) {
                    obj.mesh.rotation.y += 0.02;
                }
            });

            renderer.render(scene, camera);
        }

        // å•Ÿå‹•
        init();

    </script>
</body>
</html>